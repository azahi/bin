#!/usr/bin/env python3

import argparse
import sys
import os
from subprocess import call
import contextlib


if __name__ != '__main__':
    raise Exception("must be used as a main module with a parameter as the "
                    "input file")

PARSER = argparse.ArgumentParser(description="cleanup /etc/portage/package.* "
                                             "files")
PARSER.add_argument("infile", help="an input file to clean")
PARSER.add_argument("--out", dest="outfile", help="the output is written to "
                    "this file. if not specified, the output is written to "
                    "stdout.")
PARSER.add_argument("--inplace", action='store_true',
                    help="overwrite the in file. if specified, --out is "
                    "ignored.")

ARGS = PARSER.parse_args()


def check_installed(package):
    with open(os.devnull, 'w') as devnull:
        status = call('qlist -IC "' + str(package.split()[0].strip()) + '"',
                      shell=True, stdout=devnull)
        return status == 0


@contextlib.contextmanager
def get_out_file(args):
    if args.inplace:
        fd = open(args.infile, 'w')
    elif args.outfile is not None:
        fd = open(args.outfile, 'w')
    else:
        fd = sys.stdout
    try:
        yield fd
    finally:
        if fd is not sys.stdout:
            fd.close()


COMMENT_BUFFER = []
LINES = []

with open(ARGS.infile, 'r') as f:
    LINES = f.readlines()

with get_out_file(ARGS) as out:
    for line in LINES:
        if line.lstrip().startswith("#"):
            COMMENT_BUFFER.append(line)
        else:
            if line.strip() == "" or check_installed(line):
                if COMMENT_BUFFER:
                    out.write("".join(COMMENT_BUFFER))
                out.write(line)
            COMMENT_BUFFER = []
